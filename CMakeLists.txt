cmake_minimum_required(VERSION 3.19...3.24 FATAL_ERROR)

# -- project setup -------------------------------------------------------------

# Semicolon-separated list of directories specifying a search path for CMake.
list(PREPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
set(VAST_VERSION_TAG_BACKUP "${VAST_VERSION_TAG}")
include(VASTVersion)

# Create the VAST project.
project(
  VAST
  VERSION
    ${VAST_VERSION_MAJOR}.${VAST_VERSION_MINOR}.${VAST_VERSION_PATCH}.${VAST_VERSION_TWEAK}
  DESCRIPTION "Visibility Across Space and Time"
  HOMEPAGE_URL "https://vast.io"
  LANGUAGES C CXX)

set(VAST_EDITION_NAME
    "VAST"
    CACHE STRING "Set the edition name")

# -- sanity checks -------------------------------------------------------------

# Prohibit in-source builds.
if ("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
  message(FATAL_ERROR "In-source builds are not allowed.")
endif ()

# Check whether remnants of an earlier in-source build exist.
if (EXISTS "${CMAKE_SOURCE_DIR}/CMakeCache.txt"
    OR EXISTS "${CMAKE_SOURCE_DIR}/CMakeFiles")
  message(
    FATAL_ERROR
      "Detected an earlier in-source build; please remove CMakeCache.txt and CMakeFiles/ from your source-directory"
  )
endif ()

# Ensure that CMAKE_INSTALL_PREFIX is not a relative path.
if (NOT IS_ABSOLUTE "${CMAKE_INSTALL_PREFIX}")
  message(
    FATAL_ERROR
      "CMAKE_INSTALL_PREFIX must be an absolute path: ${CMAKE_INSTALL_PREFIX}")
endif ()

# Override `find_package` for subprojects to be a no-op when trying to find VAST
# itself. This simplifies the plugin CMake by not requiring plugin developers to
# check whether their plugin is built alongside VAST.
if ("${CMAKE_PROJECT_NAME}" STREQUAL "${PROJECT_NAME}")
  macro (find_package)
    if (NOT "${ARGV0}" STREQUAL "${CMAKE_PROJECT_NAME}")
      _find_package(${ARGV})
    endif ()
  endmacro ()
endif ()

# Set a default build type if none was specified.
set(default_build_type "Release")
if (EXISTS "${CMAKE_SOURCE_DIR}/.git")
  set(default_build_type "Debug")
endif ()

if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  message(
    STATUS
      "Setting build type to '${default_build_type}' as none was specified.")
  set(CMAKE_BUILD_TYPE
      "${default_build_type}"
      CACHE STRING "Choose the type of build." FORCE)
  # Set the possible values of build type for cmake-gui.
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
                                               "MinSizeRel" "RelWithDebInfo")
endif ()

# -- includes ------------------------------------------------------------------

include(CMakeDependentOption)
include(CMakePackageConfigHelpers)
include(CMakePrintHelpers)
include(CTest)
include(CheckCXXSourceCompiles)
include(CheckLibraryExists)
include(FeatureSummary)
include(GNUInstallDirs)
include(VASTCheckCompilerVersion)
include(VASTMacDependencyPaths)
include(VASTProvideFindModule)
include(VASTRegisterPlugin)
include(VASTUtilities)

# -- project configuration -----------------------------------------------------

# Determine whether we're building VAST a subproject. This is used to determine
# good default values for many options. VAST should not modify global CMake if
# built as a subproject, unless explicitly requested to do so with options.
get_directory_property(_VAST_PARENT_DIRECTORY PARENT_DIRECTORY)
if (_VAST_PARENT_DIRECTORY)
  set(VAST_IS_SUBPROJECT ON)
  set(VAST_IS_NOT_SUBPROJECT OFF)
else ()
  set(VAST_IS_SUBPROJECT OFF)
  set(VAST_IS_NOT_SUBPROJECT ON)
endif ()
unset(_VAST_PARENT_DIRECTORY)

# -- changelog -----------------------------------------------------------------

configure_file("${CMAKE_CURRENT_SOURCE_DIR}/cmake/VASTChangelog.cmake.in"
               "${CMAKE_CURRENT_BINARY_DIR}/VASTChangelog.cmake" @ONLY)

file(GLOB_RECURSE changelog_dependencies CONFIGURE_DEPENDS
     "${CMAKE_CURRENT_SOURCE_DIR}/changelog/**.md")

add_custom_target(
  changelog ALL
  BYPRODUCTS "${CMAKE_CURRENT_BINARY_DIR}/CHANGELOG.md"
  DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/VASTChangelog.cmake"
          ${changelog_dependencies}
  COMMAND ${CMAKE_COMMAND} -P "${CMAKE_CURRENT_BINARY_DIR}/VASTChangelog.cmake")

option(VAST_ENABLE_SKIP_AFTER_CHANGELOG_UPDATE
       "Skip build configuration after update-changelog target" OFF)
mark_as_advanced(VAST_ENABLE_SKIP_AFTER_CHANGELOG_UPDATE)
if (VAST_ENABLE_SKIP_AFTER_CHANGELOG_UPDATE)
  return()
endif ()

# -- testing -------------------------------------------------------------------

cmake_dependent_option(VAST_ENABLE_UNIT_TESTS "Build unit tests for libvast" ON
                       "NOT CMAKE_CROSS_COMPILING" OFF)
add_feature_info("VAST_ENABLE_UNIT_TESTS" VAST_ENABLE_UNIT_TESTS
                 "build unit tests for libvast.")
set(VAST_UNIT_TEST_TIMEOUT
    "60"
    CACHE STRING "The per-test timeout in unit tests" FORCE)

# -- library flavor ------------------------------------------------------------

option(BUILD_SHARED_LIBS "Build shared instead of static libraries" ON)
add_feature_info("BUILD_SHARED_LIBS" BUILD_SHARED_LIBS
                 "build shared instead of static libraries.\n")

# -- relocatable installations -------------------------------------------------

# Setting this option removes configuration dependent absolute paths from the
# VAST installation. Concretely, it enables the dynamic binary and libraries to
# use relative paths for loading their dependencies. On macOS, always enable
# relocatable installations as it's very uncommon not to do so.
cmake_dependent_option(VAST_ENABLE_RELOCATABLE_INSTALLATIONS
                       "Enable relocatable installations" ON "NOT APPLE" ON)
add_feature_info(
  "VAST_ENABLE_RELOCATABLE_INSTALLATIONS" VAST_ENABLE_RELOCATABLE_INSTALLATIONS
  "enable relocatable installations.")

if (VAST_ENABLE_RELOCATABLE_INSTALLATIONS)
  # For relocatable builds we need the configured install directories to be
  # relative so we can interpret them relative to the object path of the running
  # binary instead of a fixed install prefix.
  VASTNormalizeInstallDirs()

  # Single output directory.
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
      "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}"
      CACHE PATH "Single directory for all binaries.")
  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
      "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}"
      CACHE PATH "Single directory for all libraries.")
endif ()

# CMake allows for overriding the install prefix at install-time, e.g., via
# `cmake --install <path/to/build> --prefix <path/to/install>` or
# `DESTDIR=<path/to/install> cmake --build <path/to/build> --target install`.
# Doing so breaks non-relocatable installations, so we abort the installation
# when encountering this.
if (NOT VAST_ENABLE_RELOCATABLE_INSTALLATIONS)
  install(
    CODE "\
    cmake_minimum_required(VERSION 3.19...3.24 FATAL_ERROR)
    get_filename_component(build_time_prefix
      \"${CMAKE_INSTALL_PREFIX}\" ABSOLUTE)
    get_filename_component(install_time_prefix
      \"\${CMAKE_INSTALL_PREFIX}\" ABSOLUTE)
    if (NOT \"\${build_time_prefix}\" STREQUAL \"\${install_time_prefix}\")
      message(FATAL_ERROR
        \"For non-relocatable builds the configured build-time install prefix (\${build_time_prefix}) must match the configured install-time install prefix (\${install_time_prefix})\"
      )
    endif ()
    "
    COMPONENT Development)
endif ()

# -- internal target -----------------------------------------------------------

# Create the internal target that is used for option/property propagation.
add_library(libvast_internal INTERFACE)
set_target_properties(libvast_internal PROPERTIES EXPORT_NAME internal)
add_library(vast::internal ALIAS libvast_internal)
install(
  TARGETS libvast_internal
  EXPORT VASTTargets
  COMPONENT Development)

# Require standard C++20.
target_compile_features(libvast_internal INTERFACE cxx_std_20)

# Enable coroutines for GCC < 11.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION
                                             VERSION_LESS 11)
  target_compile_options(libvast_internal INTERFACE -fcoroutines)
endif ()

# Increase maximum number of template instantiations.
target_compile_options(libvast_internal INTERFACE -ftemplate-backtrace-limit=0)

# -- FreeBSD support -----------------------------------------------------------

if (${CMAKE_SYSTEM_NAME} MATCHES "FreeBSD")
  # Works around issues with libstdc++ and C++11. For details, see: -
  # https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=194929 -
  # https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=182657
  target_compile_definitions(
    libvast_internal INTERFACE _GLIBCXX_USE_C99 _GLIBCXX_USE_C99_MATH
                               _GLIBCXX_USE_C99_MATH_TR1)
endif ()

# -- optimizations -------------------------------------------------------------

option(VAST_ENABLE_AUTO_VECTORIZATION "Enable SSE instructions" ON)
add_feature_info(
  "VAST_ENABLE_AUTO_VECTORIZATION" VAST_ENABLE_AUTO_VECTORIZATION
  "enable auto-vectorization via supported SSE/AVX instructions.")
if (VAST_ENABLE_AUTO_VECTORIZATION)
  find_package(SSE QUIET)
  option(VAST_ENABLE_SSE_INSTRUCTIONS "Enable SSE instructions" "${SSE_FOUND}")
  add_feature_info("VAST_ENABLE_SSE_INSTRUCTIONS" VAST_ENABLE_SSE_INSTRUCTIONS
                   "enable SSE instructions.")
  option(VAST_ENABLE_SSE2_INSTRUCTIONS "Enable SSE2 instructions"
         "${SSE2_FOUND}")
  add_feature_info("VAST_ENABLE_SSE2_INSTRUCTIONS"
                   VAST_ENABLE_SSE2_INSTRUCTIONS "enable SSE2 instructions.")
  option(VAST_ENABLE_SSE3_INSTRUCTIONS "Enable SSE3 instructions"
         "${SSE3_FOUND}")
  add_feature_info("VAST_ENABLE_SSE3_INSTRUCTIONS"
                   VAST_ENABLE_SSE3_INSTRUCTIONS "enable SSE3 instructions.")
  option(VAST_ENABLE_SSSE3_INSTRUCTIONS "Enable SSSE3 instructions"
         "${SSSE3_FOUND}")
  add_feature_info("VAST_ENABLE_SSSE3_INSTRUCTIONS"
                   VAST_ENABLE_SSSE3_INSTRUCTIONS "enable SSSE3 instructions.")
  option(VAST_ENABLE_SSE4_1_INSTRUCTIONS "Enable SSE4.1 instructions"
         "${SSE4_1_FOUND}")
  add_feature_info(
    "VAST_ENABLE_SSE4_1_INSTRUCTIONS" VAST_ENABLE_SSE4_1_INSTRUCTIONS
    "enable SSE4.1 instructions.")
  option(VAST_ENABLE_SSE4_2_INSTRUCTIONS "Enable SSE4.2 instructions"
         "${SSE4_2_FOUND}")
  add_feature_info(
    "VAST_ENABLE_SSE4_2_INSTRUCTIONS" VAST_ENABLE_SSE4_2_INSTRUCTIONS
    "enable SSE4.2 instructions.")
  option(VAST_ENABLE_AVX_INSTRUCTIONS "Enable AVX instructions" "${AVX_FOUND}")
  add_feature_info("VAST_ENABLE_AVX_INSTRUCTIONS" VAST_ENABLE_AVX_INSTRUCTIONS
                   "enable AVX instructions.")
  option(VAST_ENABLE_AVX2_INSTRUCTIONS "Enable AVX2 instructions"
         "${AVX2_FOUND}")
  add_feature_info("VAST_ENABLE_AVX2_INSTRUCTIONS"
                   VAST_ENABLE_AVX2_INSTRUCTIONS "enable AVX2 instructions.")
endif ()

target_compile_options(
  libvast_internal
  INTERFACE $<$<CONFIG:Release>:
            -fno-omit-frame-pointer>
            $<$<CONFIG:RelWithDebInfo>:-fno-omit-frame-pointer>
            $<$<CONFIG:Debug>:-O0>
            $<$<CONFIG:CI>:-O2
            -g1>
            $<$<BOOL:${VAST_ENABLE_SSE_INSTRUCTIONS}>:-msse>
            $<$<BOOL:${VAST_ENABLE_SSE2_INSTRUCTIONS}>:-msse2>
            $<$<BOOL:${VAST_ENABLE_SSE3_INSTRUCTIONS}>:-msse3>
            $<$<BOOL:${VAST_ENABLE_SSSE3_INSTRUCTIONS}>:-mssse3>
            $<$<BOOL:${VAST_ENABLE_SSE4_1_INSTRUCTIONS}>:-msse4.1>
            $<$<BOOL:${VAST_ENABLE_SSE4_2_INSTRUCTIONS}>:-msse4.2>
            $<$<BOOL:${VAST_ENABLE_AVX_INSTRUCTIONS}>:-mavx>
            $<$<BOOL:${VAST_ENABLE_AVX2_INSTRUCTIONS}>:-mavx2>)

# -- warnings ------------------------------------------------------------------

if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  target_compile_options(libvast_internal INTERFACE -Wno-unknown-warning-option)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
  target_compile_options(libvast_internal INTERFACE -Wno-unknown-warning)
endif ()

target_compile_options(
  libvast_internal
  INTERFACE -Wall
            -Wextra
            -pedantic
            -Werror=switch
            -Werror=odr
            -Wundef
            $<$<CONFIG:CI>:-Werror
            # Never treat deprecation warnings as errors.
            -Wno-error=deprecated
            -Wno-error=deprecated-declarations>
            $<$<CXX_COMPILER_ID:GNU>:-Wno-redundant-move>
            $<$<CXX_COMPILER_ID:GNU>:-Wno-error=bool-compare>)

# -- build id ------------------------------------------------------------------

cmake_dependent_option(
  VAST_ENABLE_BUILDID "Include a unique identifier in the elf notes section" ON
  "CMAKE_EXECUTABLE_FORMAT STREQUAL ELF" OFF)
add_feature_info("VAST_ENABLE_BUILDID" VAST_ENABLE_BUILDID
                 "a unique identifier in the ELF notes section.")
if (VAST_ENABLE_BUILDID)
  target_link_options(libvast_internal INTERFACE "-Wl,--build-id")
endif ()

# -- USDT tracepoints ----------------------------------------------------------

option(VAST_ENABLE_SDT "Generate USDT tracepoint instrumentation" ON)
add_feature_info("VAST_ENABLE_SDT" VAST_ENABLE_SDT
                 "generate USDT tracepoint instrumentation.")

# -- build profiling -----------------------------------------------------------

option(VAST_ENABLE_TIME_REPORT
       "Print information where time was spent during compilation" OFF)
add_feature_info("VAST_ENABLE_TIME_REPORT" VAST_ENABLE_TIME_REPORT
                 "print information where time was spent during compilation.")
if (VAST_ENABLE_TIME_REPORT)
  target_compile_options(libvast_internal INTERFACE "-ftime-report")
endif ()

option(VAST_ENABLE_TIME_TRACE
       "Generate tracing JSON for compilation time profiling" OFF)
add_feature_info("VAST_ENABLE_TIME_TRACE" VAST_ENABLE_TIME_TRACE
                 "generate tracing JSON for compilation time profiling.")
if (VAST_ENABLE_TIME_TRACE)
  include(CheckCXXCompilerFlag)
  check_cxx_compiler_flag("-ftime-trace" _time_trace_supported)
  if (NOT _time_trace_supported)
    message(
      FATAL_ERROR
        "-ftime-trace option not supported by compiler ${CMAKE_CXX_COMPILER}")
  endif ()
  unset(_time_trace_supported)
  target_compile_options(libvast_internal INTERFACE "-ftime-trace")
endif ()

# -- assertions ----------------------------------------------------------------

if (CMAKE_BUILD_TYPE STREQUAL Release)
  set(_VAST_ENABLE_ASSERTIONS_DEFAULT OFF)
else ()
  set(_VAST_ENABLE_ASSERTIONS_DEFAULT ON)
endif ()

option(VAST_ENABLE_ASSERTIONS "Enable assertions"
       "${_VAST_ENABLE_ASSERTIONS_DEFAULT}")
add_feature_info("VAST_ENABLE_ASSERTIONS" VAST_ENABLE_ASSERTIONS
                 "enable assertions.")

unset(_VAST_ENABLE_ASSERTIONS_DEFAULT)

option(VAST_ENABLE_ASSERTIONS_CHEAP "Enable cheap assertions" ON)
add_feature_info("VAST_ENABLE_ASSERTIONS_CHEAP" VAST_ENABLE_ASSERTIONS_CHEAP
                 "enable assertions that are cheap to check.")

# -- static build support ------------------------------------------------------

cmake_dependent_option(
  VAST_ENABLE_STATIC_EXECUTABLE "Link VAST statically."
  "$ENV{VAST_ENABLE_STATIC_EXECUTABLE}" "NOT BUILD_SHARED_LIBS" OFF)
add_feature_info("VAST_ENABLE_STATIC_EXECUTABLE" VAST_ENABLE_STATIC_EXECUTABLE
                 "link VAST statically.")
if (VAST_ENABLE_STATIC_EXECUTABLE)
  target_link_libraries(libvast_internal INTERFACE -static-libgcc
                                                   -static-libstdc++ -static)
endif ()

if (VAST_ENABLE_STATIC_EXECUTABLE AND BUILD_SHARED_LIBS)
  message(FATAL_ERROR "Cannot create static binary with dynamic libraries")
endif ()

if (VAST_ENABLE_RELOCATABLE_INSTALLATIONS)
  # Note that we cannot use the target property INSTALL_RPATH on
  # libvast_internal, because it is an interface library. We should probably fix
  # this by making the config header part of libvast_internal so it is not just
  # an interface library.
  if (NOT VAST_ENABLE_STATIC_EXECUTABLE)
    if (APPLE)
      list(PREPEND CMAKE_INSTALL_RPATH
           "@executable_path/../${CMAKE_INSTALL_LIBDIR}")
    else ()
      list(PREPEND CMAKE_INSTALL_RPATH "$ORIGIN/../${CMAKE_INSTALL_LIBDIR}")
    endif ()
  endif ()

  # For relocatable builds we need to find the relative difference between the
  # install prefix and the library location, or the binary location for static
  # VAST binaries.
  if (VAST_ENABLE_STATIC_EXECUTABLE)
    set(_libdir "${CMAKE_INSTALL_FULL_BINDIR}")
  else ()
    set(_libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
  endif ()
  file(RELATIVE_PATH VAST_LIBDIR_TO_PREFIX "${_libdir}"
       "${CMAKE_INSTALL_PREFIX}")
  unset(_libdir)
endif ()

# -- sanitizers ----------------------------------------------------------------

# Address Sanitizer
set(_vast_build_types_with_default_asan "Debug;CI")
if (NOT VAST_ENABLE_STATIC_EXECUTABLE AND CMAKE_BUILD_TYPE IN_LIST
                                          _vast_build_types_with_default_asan)
  set(_VAST_ENABLE_ASAN_DEFAULT ON)
else ()
  set(_VAST_ENABLE_ASAN_DEFAULT OFF)
endif ()

option(VAST_ENABLE_ASAN
       "Insert pointer and reference checks into the generated binaries"
       "${_VAST_ENABLE_ASAN_DEFAULT}")
add_feature_info(
  "VAST_ENABLE_ASAN" VAST_ENABLE_ASAN
  "inserts pointer and reference checks into the generated binaries.")

unset(_VAST_ENABLE_ASAN_DEFAULT)

if (VAST_ENABLE_ASAN)
  # We need to enable the address sanitizer both globally and for the
  # libvast_internal targets in order to build (1) the bundled CAF with it and
  # (2) build external plugins with it.
  add_compile_options(-fsanitize=address -fno-omit-frame-pointer)
  add_link_options(-fsanitize=address)
  target_compile_options(libvast_internal INTERFACE -fsanitize=address
                                                    -fno-omit-frame-pointer)
  target_link_libraries(libvast_internal INTERFACE -fsanitize=address)
endif ()

# Undefined Behavior Sanitizer
option(VAST_ENABLE_UBSAN
       "Add run-time checks for undefined behavior into the generated binaries"
       OFF)
add_feature_info(
  "VAST_ENABLE_UBSAN" VAST_ENABLE_UBSAN
  "adds run-time checks for undefined behavior into the generated binaries.")
if (VAST_ENABLE_UBSAN)
  add_compile_options(-fsanitize=undefined)
  add_link_options(-fsanitize=undefined)
  target_compile_options(libvast_internal INTERFACE -fsanitize=undefined)
  target_link_libraries(libvast_internal INTERFACE -fsanitize=undefined)
endif ()

# -- jemalloc ------------------------------------------------------------------

option(VAST_ENABLE_JEMALLOC "Use jemalloc instead of libc malloc"
       "${VAST_ENABLE_STATIC_EXECUTABLE}")
add_feature_info("VAST_ENABLE_JEMALLOC" VAST_ENABLE_JEMALLOC
                 "use jemalloc instead of libc malloc.")
if (VAST_ENABLE_JEMALLOC)
  find_package(jemalloc REQUIRED)
  provide_find_module(jemalloc)
  string(APPEND VAST_FIND_DEPENDENCY_LIST "\nfind_package(jemalloc REQUIRED)")
  target_link_libraries(libvast_internal INTERFACE jemalloc::jemalloc_)
  dependency_summary("jemalloc" jemalloc::jemalloc_ "Dependencies")
endif ()

# -- developer mode ------------------------------------------------------------

option(VAST_ENABLE_CLANG_TIDY "Run clang-tidy during build" OFF)
add_feature_info("VAST_ENABLE_CLANG_TIDY" VAST_ENABLE_CLANG_TIDY
                 "run clang-tidy during build.")
set(VAST_CLANG_TIDY_ARGS
    "clang-tidy;--config-file=${PROJECT_SOURCE_DIR}/.clang-tidy")

option(VAST_ENABLE_CODE_COVERAGE "Add code coverage targets" OFF)
add_feature_info("VAST_ENABLE_CODE_COVERAGE" VAST_ENABLE_CODE_COVERAGE
                 "add code coverage targets.")
if (VAST_ENABLE_CODE_COVERAGE)
  if (NOT CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(
      WARNING
        "Code coverage reports may be inaccurate for compilers other than gcc")
  endif ()
  set(CODE_COVERAGE "${VAST_ENABLE_CODE_COVERAGE}")
  include(CodeCoverage)
  mark_as_advanced(CODE_COVERAGE)
  install(CODE "\
    cmake_minimum_required(VERSION 3.19...3.24 FATAL_ERROR)
    message(FATAL_ERROR \"Builds with code coverage must not be installed.\")")
endif ()

VASTTargetEnableTooling(libvast_internal INTERFACE)

# Add a custom executable that runs the CMake build targets 'test' and
# 'integration' so we can instrument them toether for combined code coverage.
if (VAST_ENABLE_CODE_COVERAGE)
  configure_file("${CMAKE_CURRENT_SOURCE_DIR}/cmake/all_tests.c.in"
                 "${CMAKE_CURRENT_BINARY_DIR}/cmake/all_tests.c" @ONLY)
  add_executable(all-tests "${CMAKE_CURRENT_BINARY_DIR}/cmake/all_tests.c")
  VASTTargetEnableTooling(all-tests AUTO)
endif ()

# Build VAST in developer mode. This is enabled by default when not building
# VAST as a subproject. The developer mode contains CCache support and many
# other niceties.
option(VAST_ENABLE_DEVELOPER_MODE
       "Enables build settings for a nicer development environment"
       "${VAST_IS_NOT_SUBPROJECT}")
add_feature_info("VAST_ENABLE_DEVELOPER_MODE" VAST_ENABLE_DEVELOPER_MODE
                 "enables build settings for a nicer development environment.")

if (VAST_ENABLE_DEVELOPER_MODE)
  # Support tools like clang-tidy by creating a compilation database and
  # copying it to the project root.
  VASTExportCompileCommands(libvast_internal)

  # Force colored output for the Ninja generator
  if ("${CMAKE_GENERATOR}" MATCHES "Ninja")
    if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
      target_compile_options(libvast_internal
                             INTERFACE -fdiagnostics-color=always)
    elseif ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
      target_compile_options(libvast_internal INTERFACE -fcolor-diagnostics)
    endif ()
  endif ()

  # Keep make output sane
  set(CMAKE_VERBOSE_MAKEFILE
      OFF
      CACHE STRING "Show all outputs including compiler lines." FORCE)

  # Enable CAF's compile-time type ID checks.
  target_compile_definitions(libvast_internal
                             INTERFACE CAF_ENABLE_TYPE_ID_CHECKS)
endif ()

if (VAST_ENABLE_DEVELOPER_MODE OR VAST_ENABLE_BUILDID)
  # Relocate debug paths to a common prefix for CCache users that work from
  # multiple worktrees.
  # The debug paths affect the build-id, we rewrite them to get a more
  # reproducible build.
  target_compile_options(
    libvast_internal
    INTERFACE "-fdebug-prefix-map=${CMAKE_CURRENT_SOURCE_DIR}=.")
endif ()

option(VAST_ENABLE_UPDATE_INTEGRATION_REFERENCES
       "Update references when running in integration tests" OFF)
add_feature_info(
  "VAST_ENABLE_UPDATE_INTEGRATION_REFERENCES"
  VAST_ENABLE_UPDATE_INTEGRATION_REFERENCES
  "update references when running integration tests.")

# -- additional warnings -------------------------------------------------------

option(VAST_ENABLE_MORE_WARNINGS "Enable addditional warnings" OFF)
add_feature_info("VAST_ENABLE_MORE_WARNINGS" VAST_ENABLE_MORE_WARNINGS
                 "enable additional warnings.")
if (VAST_ENABLE_MORE_WARNINGS)
  if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    target_compile_options(
      libvast_internal
      INTERFACE -Weverything
                -Wno-c++98-compat
                -Wno-padded
                -Wno-documentation-unknown-command
                -Wno-exit-time-destructors
                -Wno-global-constructors
                -Wno-missing-prototypes
                -Wno-c++98-compat-pedantic
                -Wno-unused-member-function
                -Wno-unused-const-variable
                -Wno-switch-enum
                -Wno-abstract-vbase-init
                -Wno-missing-noreturn
                -Wno-covered-switch-default)
  elseif (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
    target_compile_options(
      libvast_internal
      INTERFACE -Waddress
                -Wall
                -Warray-bounds
                -Wattributes
                -Wbuiltin-macro-redefined
                -Wcast-align
                -Wcast-qual
                -Wchar-subscripts
                -Wclobbered
                -Wcomment
                -Wconversion
                -Wconversion-null
                -Wcoverage-mismatch
                -Wcpp
                -Wdelete-non-virtual-dtor
                -Wdeprecated
                -Wdeprecated-declarations
                -Wdiv-by-zero
                -Wdouble-promotion
                -Wempty-body
                -Wendif-labels
                -Wenum-compare
                -Wextra
                -Wfloat-equal
                -Wformat
                -Wfree-nonheap-object
                -Wignored-qualifiers
                -Winit-self
                -Winline
                -Wint-to-pointer-cast
                -Winvalid-memory-model
                -Winvalid-offsetof
                -Wlogical-op
                -Wmain
                -Wmaybe-uninitialized
                -Wmissing-braces
                -Wmultichar
                -Wnarrowing
                -Wnoexcept
                -Wnon-template-friend
                -Wnon-virtual-dtor
                -Wnonnull
                -Woverflow
                -Woverlength-strings
                -Wparentheses
                -Wpmf-conversions
                -Wpointer-arith
                -Wreorder
                -Wreturn-type
                -Wsequence-point
                -Wsign-compare
                -Wswitch
                -Wtype-limits
                -Wundef
                -Wuninitialized
                -Wunused
                -Wvla
                -Wwrite-strings
                -Wno-redundant-move)
  endif ()
endif ()

# -- compiler setup ------------------------------------------------------------

set(CLANG_MINIMUM_VERSION 13.0)
set(APPLE_CLANG_MINIMUM_VERSION 14.0)
set(GCC_MINIMUM_VERSION 10.0)

if ("${CMAKE_CXX_COMPILER_ID}" MATCHES "GNU")
  check_compiler_version(${GCC_MINIMUM_VERSION})
elseif ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
  if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang")
    check_compiler_version(${APPLE_CLANG_MINIMUM_VERSION})
  else ()
    check_compiler_version(${CLANG_MINIMUM_VERSION})
  endif ()
else ()
  message(WARNING "Unsupported compiler: ${CMAKE_CXX_COMPILER_ID}")
endif ()

# -- schemas -------------------------------------------------------------------

option(VAST_ENABLE_BUNDLED_SCHEMAS "Install bundled schemas with VAST" ON)
add_feature_info("VAST_ENABLE_BUNDLED_SCHEMAS" VAST_ENABLE_BUNDLED_SCHEMAS
                 "install bundled schemas with VAST.")
if (VAST_ENABLE_RELOCATABLE_INSTALLATIONS)
  add_custom_target(
    vast-schema
    COMMAND
      ${CMAKE_COMMAND} -E copy_directory "${CMAKE_CURRENT_SOURCE_DIR}/schema"
      "${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_DATADIR}/vast/schema/"
    COMMENT "Copying schema directory")
endif ()

if (VAST_ENABLE_BUNDLED_SCHEMAS)
  install(
    DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/schema"
    DESTINATION "${CMAKE_INSTALL_DATADIR}/vast"
    COMPONENT Runtime)
endif ()

# -- manpages ------------------------------------------------------------------

option(VAST_ENABLE_MANPAGES "Generate manpages for binaries" ON)
add_feature_info("VAST_ENABLE_MANPAGES" VAST_ENABLE_MANPAGES
                 "generate manpages for binaries.")
if (VAST_ENABLE_MANPAGES)
  find_package(Pandoc REQUIRED)
endif ()

# -- caf -----------------------------------------------------------------------

# The CAF dependency is loaded project-wide because both libvast and
# libvast_test need it.

# CAF::openssl needs OpenSSL, but CAFConfig.cmake does not pull it in.
find_package(OpenSSL REQUIRED)

# TODO: Require CAF to be installed.

if (VAST_ENABLE_DEVELOPER_MODE
    AND EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/libvast/aux/caf/CMakeLists.txt"
    AND NOT CAF_ROOT_DIR)
  set(VAST_ENABLE_BUNDLED_CAF_DEFAULT ON)
else ()
  set(VAST_ENABLE_BUNDLED_CAF_DEFAULT OFF)
endif ()
option(VAST_ENABLE_BUNDLED_CAF "Use the CAF submodule"
       "${VAST_ENABLE_BUNDLED_CAF_DEFAULT}")
add_feature_info("VAST_ENABLE_BUNDLED_CAF" VAST_ENABLE_BUNDLED_CAF
                 "use the CAF submodule.")
if (NOT VAST_ENABLE_BUNDLED_CAF)
  # Try to find the required CAF components first...
  find_package(
    CAF
    COMPONENTS core io test openssl
    REQUIRED)
  if (NOT ${CAF_VERSION} VERSION_GREATER_EQUAL 0.18.6)
    message(
      FATAL_ERROR "Failed to find CAF >= 0.18.6 version (found ${CAF_VERSION})")
  endif ()
  string(
    APPEND
    VAST_FIND_DEPENDENCY_LIST
    "\nfind_package(CAF ${CAF_VERSION} COMPONENTS core io test openssl REQUIRED)"
  )
  dependency_summary("CAF" CAF::core "Dependencies")
else ()
  # Use bundled CAF.
  if (NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/libvast/aux/caf/CMakeLists.txt")
    message(
      FATAL_ERROR
        "CAF not found, either use -DCAF_ROOT_DIR=... or initialize the libvast/aux/caf submodule"
    )
  else ()
    set(VAST_ENABLE_BUNDLED_CAF ON)
    set(CAF_LOG_LEVEL ${VAST_CAF_LOG_LEVEL})
    set(CAF_ENABLE_EXAMPLES OFF)
    set(CAF_ENABLE_TESTING OFF)
    set(CAF_ENABLE_TOOLS OFF)
    set(CAF_ENABLE_OPENSSL ON)
    # add_subdirectory libvast/aux/caf checks if compiler supports the c++ 17. This check fails and the workaround
    # can be removed once CAF cmake changes to use set(CMAKE_CXX_STANDARD) instead of it's own check
    set(ORIGINAL_CXX_STANDARD ${CMAKE_CXX_STANDARD})
    set(CMAKE_CXX_STANDARD 17)
    add_subdirectory(libvast/aux/caf)
    set(CMAKE_CXX_STANDARD ${ORIGINAL_CXX_STANDARD})
    VASTSystemizeTarget(libcaf_core)
    set_target_properties(libcaf_core PROPERTIES EXPORT_NAME core)
    target_compile_features(libcaf_core INTERFACE cxx_std_17)
    target_compile_options(
      libcaf_core
      PRIVATE
        -Wno-maybe-uninitialized
        -Wno-unqualified-std-cast-call
        -Wno-unknown-warning-option
        $<$<CXX_COMPILER_ID:Clang,AppleClang>:-Wno-deprecated-declarations>
        $<$<CXX_COMPILER_ID:GNU>:-Wno-deprecated>)
    VASTSystemizeTarget(libcaf_io)
    set_target_properties(libcaf_io PROPERTIES EXPORT_NAME io)
    target_compile_options(
      libcaf_io PRIVATE -Wno-maybe-uninitialized -Wno-unqualified-std-cast-call
                        -Wno-unknown-warning-option)
    if (NOT TARGET libcaf_openssl)
      string(
        JOIN " " err_message
        "Unable to find the bundled CAF's OpenSSL module; consider setting "
        "OPENSSL_ROOT_DIR to the install prefix of your OpenSSL installation.")
      message(FATAL_ERROR "${err_message}")
    endif ()
    target_include_directories(
      libcaf_openssl
      PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/libvast/aux/caf/libcaf_openssl>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
    VASTSystemizeTarget(libcaf_openssl)
    set_target_properties(libcaf_openssl PROPERTIES EXPORT_NAME openssl)
    VASTSystemizeTarget(libcaf_test)
    set_target_properties(libcaf_test PROPERTIES EXPORT_NAME test)
    mark_as_advanced(caf_build_header_path)
    string(APPEND VAST_EXTRA_TARGETS_FILES
           "\ninclude(\"\${CMAKE_CURRENT_LIST_DIR}/../CAF/CAFTargets.cmake\")"
           "\nmark_as_advanced(caf_build_header_path)")
    set(CAF_FOUND true)
  endif ()
  # Make bundled CAF available for component-based CPack installations.
  install(TARGETS libcaf_core libcaf_openssl libcaf_io COMPONENT Runtime)
  install(TARGETS libcaf_test COMPONENT Development)
  # Figure out whether we point to a build directory or a prefix.
  dependency_summary("CAF" "${CMAKE_CURRENT_SOURCE_DIR}/libvast/aux/caf"
                     "Dependencies")
endif ()

if (VAST_ENABLE_RELOCATABLE_INSTALLATIONS
    AND BUILD_SHARED_LIBS
    AND CAF_LIBRARY_CORE)
  # Copy CAF libraries to installation directory
  get_filename_component(CAF_LIBDIR ${CAF_LIBRARY_CORE} PATH)
  file(GLOB CAF_INSTALLED_LIBRARIES "${CAF_LIBDIR}/libcaf*.so")
  install(
    FILES ${CAF_INSTALLED_LIBRARIES}
    DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    COMPONENT Runtime)
endif ()

# -- add subdirectories --------------------------------------------------------

add_subdirectory(libvast)
add_subdirectory(libvast_test)
add_subdirectory(contrib/tools)
add_subdirectory(vast)

# -- cmake export/config installations -----------------------------------------

export(
  EXPORT VASTTargets
  FILE VASTTargets.cmake
  NAMESPACE vast::)

install(
  EXPORT VASTTargets
  DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/vast"
  NAMESPACE vast::
  COMPONENT Development)

write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/VASTConfigVersion.cmake"
  VERSION "${VAST_VERSION_MAJOR}.${VAST_VERSION_MINOR}.${VAST_VERSION_PATCH}"
  COMPATIBILITY ExactVersion)

configure_package_config_file(
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/VASTConfig.cmake.in"
  "${CMAKE_CURRENT_BINARY_DIR}/VASTConfig.cmake"
  INSTALL_DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/vast")

install(
  FILES "${CMAKE_CURRENT_SOURCE_DIR}/cmake/VASTRegisterPlugin.cmake"
        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/VASTMacDependencyPaths.cmake"
        "${CMAKE_CURRENT_BINARY_DIR}/VASTConfig.cmake"
        "${CMAKE_CURRENT_BINARY_DIR}/VASTConfigVersion.cmake"
  DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/vast"
  COMPONENT Development)

# -- scripts -------------------------------------------------------------------

# TODO: Make other scripts installable as well.

option(VAST_ENABLE_CORELIGHT_CAT "Install corelight-cat with VAST" OFF)
add_feature_info("VAST_ENABLE_CORELIGHT_CAT" VAST_ENABLE_CORELIGHT_CAT
                 "install corelight-cat with VAST.")
if (VAST_ENABLE_CORELIGHT_CAT)
  install(
    FILES "${CMAKE_CURRENT_SOURCE_DIR}/scripts/corelight-cat"
    # These should be inherited from the source but they
    # get lost in CPack, so we set them explicitly.
    PERMISSIONS
      OWNER_READ
      OWNER_WRITE
      OWNER_EXECUTE
      GROUP_READ
      GROUP_EXECUTE
      WORLD_READ
      WORLD_EXECUTE
    DESTINATION "${CMAKE_INSTALL_BINDIR}"
    COMPONENT Runtime)
endif ()

option(VAST_ENABLE_VAST_DF_PERCENT "Install vast-df-percent.sh with VAST" ON)
add_feature_info("VAST_ENABLE_VAST_DF_PERCENT" VAST_ENABLE_VAST_DF_PERCENT
                 "install vast-df-percent.sh with VAST.")
if (VAST_ENABLE_VAST_DF_PERCENT)
  install(
    FILES "${CMAKE_CURRENT_SOURCE_DIR}/scripts/vast-df-percent.sh"
    # These should be inherited from the source but they
    # get lost in CPack, so we set them explicitly.
    PERMISSIONS
      OWNER_READ
      OWNER_WRITE
      OWNER_EXECUTE
      GROUP_READ
      GROUP_EXECUTE
      WORLD_READ
      WORLD_EXECUTE
    DESTINATION "${CMAKE_INSTALL_LIBEXECDIR}"
    COMPONENT Runtime)
endif ()

# -- docdir --------------------------------------------------------------------

# Install CHANGELOG, LICENSE, README, and VERSIONING. This can intentionally not
# be disabled.
install(
  FILES "${CMAKE_CURRENT_BINARY_DIR}/CHANGELOG.md"
        "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE"
        "${CMAKE_CURRENT_SOURCE_DIR}/VAST.spdx"
        "${CMAKE_CURRENT_SOURCE_DIR}/VERSIONING.md"
        "${CMAKE_CURRENT_SOURCE_DIR}/README.md"
  DESTINATION "${CMAKE_INSTALL_DOCDIR}"
  COMPONENT Runtime)

# -- python bindings ----------------------------------------------------------

option(VAST_ENABLE_PYTHON_BINDINGS "Install Python bindings (requires poetry)"
       ON)
add_feature_info("VAST_ENABLE_PYTHON_BINDINGS" VAST_ENABLE_PYTHON_BINDINGS
                 "install Python bindings (requires poetry).")
# Currently, we install all dependencies for the Python bindings alongside the
# Python bindings by default. We are not sure whether this is a good choice, or
# whether it works well with the Nix sandbox, so this may change in the future.
cmake_dependent_option(
  VAST_ENABLE_PYTHON_BINDINGS_DEPENDENCIES
  "Install Python bindings with dependencies" ON "VAST_ENABLE_PYTHON_BINDINGS"
  OFF)
add_feature_info(
  "VAST_ENABLE_PYTHON_BINDINGS_DEPENDENCIES"
  VAST_ENABLE_PYTHON_BINDINGS_DEPENDENCIES
  "install Python bindings with dependencies.")
if (VAST_ENABLE_PYTHON_BINDINGS)
  find_program(POETRY_PATH poetry)
  if (NOT POETRY_PATH)
    message(
      FATAL_ERROR
        "Cannot find 'poetry' in PATH, which is required for installing VAST Python bindings"
    )
  endif ()
  # Poetry has no support for specifying a working directory for the build
  # command, so in order to make the installation not modify the source directory
  # we need to copy the Python bindings in their entirety into the build directory
  # first.
  unset(VAST_POETRY_EXTRA_INSTALL_ARGS)
  if (NOT VAST_ENABLE_PYTHON_BINDINGS_DEPENDENCIES)
    list(APPEND VAST_POETRY_EXTRA_INSTALL_ARGS "--no-deps")
  endif ()
  install(
    CODE "
    cmake_minimum_required(VERSION 3.19...3.24 FATAL_ERROR)
    file(REMOVE_RECURSE \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python\")
    file(MAKE_DIRECTORY \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python\")
    file(
      COPY \"${CMAKE_CURRENT_SOURCE_DIR}/python/\"
      DESTINATION \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python\")
    # Poetry evaluates the top-level gitignore, which leads it to ignore
    # everything in case the install prefix is in an ignored path. Setting the
    # git directory explicitly works around the issue.
    set(ENV{GIT_DIR} \"/dev/null\")
    execute_process(
      COMMAND \"${POETRY_PATH}\" build --no-interaction --format=wheel -vvv
      WORKING_DIRECTORY \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python\"
      COMMAND_ERROR_IS_FATAL ANY)
    file(
      GLOB VAST_PYTHON_WHL
      \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python/dist/*.whl\")
    file(
      GLOB VAST_OLD_INSTALLED_BINS
      \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}/*\")
    execute_process(
      COMMAND \"${POETRY_PATH}\" run pip install
        ${VAST_POETRY_EXTRA_INSTALL_ARGS}
        --prefix \"\${CMAKE_INSTALL_PREFIX}\"
        \"\${VAST_PYTHON_WHL}\"
      WORKING_DIRECTORY \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/vast/python\"
      COMMAND_ERROR_IS_FATAL ANY)
    file(
      GLOB VAST_NEW_INSTALLED_BINS
      \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}/*\")
    foreach (bin IN LISTS VAST_NEW_INSTALLED_BINS)
      if (NOT \"\${bin}\" IN_LIST VAST_OLD_INSTALLED_BINS)
        file(REMOVE \"\${bin}\")
      endif ()
    endforeach ()"
    COMPONENT Runtime)
endif ()

# -- packaging -----------------------------------------------------------------

include(VASTPackage)

# -- feature summary -----------------------------------------------------------

# Append the feature summary to summary.log.
feature_summary(
  WHAT ALL
  FILENAME "${CMAKE_CURRENT_BINARY_DIR}/summary.log"
  APPEND)

# Print the feature and build summary if we're not a subproject.
if (NOT VAST_IS_SUBPROJECT)
  feature_summary(WHAT ENABLED_FEATURES DISABLED_FEATURES
                  INCLUDE_QUIET_PACKAGES)
  unset(build_summary)
  list(APPEND build_summary "Build summary:\n")
  list(APPEND build_summary " * Edition: ${VAST_EDITION_NAME}")
  list(APPEND build_summary " * Version: ${VAST_VERSION_TAG}")
  list(APPEND build_summary " * Build Tree Hash: ${VAST_BUILD_TREE_HASH}")
  list(APPEND build_summary "")
  if (CMAKE_CONFIGURATION_TYPES)
    list(APPEND build_summary
         " * Configuration Types: ${CMAKE_CONFIGURATION_TYPES}")
  else ()
    list(APPEND build_summary " * Build Type: ${CMAKE_BUILD_TYPE}")
  endif ()
  list(APPEND build_summary " * Source Directory: ${CMAKE_SOURCE_DIR}")
  list(APPEND build_summary " * Binary Directory: ${CMAKE_BINARY_DIR}\n")
  list(APPEND build_summary " * System Name: ${CMAKE_SYSTEM_NAME}")
  list(APPEND build_summary " * CPU: ${CMAKE_SYSTEM_PROCESSOR}")
  foreach (lang IN ITEMS C CXX)
    set(_lang_compiler "${CMAKE_${lang}_COMPILER}")
    set(_lang_compiler_info
        "${CMAKE_${lang}_COMPILER_ID} ${CMAKE_${lang}_COMPILER_VERSION}")
    set(_lang_flags
        "${CMAKE_${lang}_FLAGS} ${CMAKE_${lang}_FLAGS_${CMAKE_BUILD_TYPE}}
      ${CMAKE_CPP_FLAGS} ${CMAKE_CPP_FLAGS_${CMAKE_BUILD_TYPE}}")
    string(STRIP "${_lang_flags}" _lang_flags)
    if (_lang_flags)
      list(
        APPEND
        build_summary
        " * ${lang} Compiler: ${_lang_compiler} (${_lang_compiler_info} with ${_lang_flags})"
      )
    else ()
      list(APPEND build_summary
           " * ${lang} Compiler: ${_lang_compiler} (${_lang_compiler_info})")
    endif ()
  endforeach ()
  list(APPEND build_summary " * Linker: ${CMAKE_LINKER}")
  list(APPEND build_summary " * Archiver: ${CMAKE_AR}")
  list(APPEND build_summary "")
  list(JOIN build_summary "\n" build_summary_joined)
  message(STATUS "${build_summary_joined}")
  get_property(VAST_DEPENDENCY_SUMMARY_CATEGORIES GLOBAL
               PROPERTY "VAST_DEPENDENCY_SUMMARY_CATEGORIES_PROPERTY")
  foreach (category IN LISTS VAST_DEPENDENCY_SUMMARY_CATEGORIES)
    get_property(VAST_DEPENDENCY_SUMMARY GLOBAL
                 PROPERTY "VAST_DEPENDENCY_SUMMARY_${category}_PROPERTY")
    if (VAST_DEPENDENCY_SUMMARY)
      unset(build_summary)
      list(APPEND build_summary "${category}:")
      foreach (summary IN LISTS VAST_DEPENDENCY_SUMMARY)
        list(APPEND build_summary "${summary}")
      endforeach ()
      list(APPEND build_summary "")
      list(JOIN build_summary "\n" build_summary_joined)
      message(STATUS "${build_summary_joined}")
    endif ()
  endforeach ()
endif ()
